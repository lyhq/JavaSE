package com.lyhq.design.patterns.Interpreter;

/**
 * 解释器模式
 * 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
 * 
 * 解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！
 * 
 * 参与者
 *  1.AbstractExpression(抽象表达式)
 *  声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。
 *  2.TerminalExpression(终结符表达式)
 *  实现与文法中的终结符相关联的解释操作。
 *  一个句子中的每个终结符需要该类的一个实例。
 *  3.NonterminalExpression(非终结符表达式)
 *  为文法中的非终结符实现解释(Interpret)操作。
 *  4.Context（上下文）
 *  包含解释器之外的一些全局信息。
 *  5.Client（客户）
 *  构建(或被给定)表示该文法定义的语言中一个特定的句子的抽象语法树。
 *  该抽象语法树由NonterminalExpression和TerminalExpression的实例装配而成。调用解释操作。
 * 
 * 组成结构
 * 一个解释器模式中包含的四种角色
 * 	1）抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，
 * 	称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器和非终结符解释器完成。
 * 	2）终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，
 * 	但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，
 * 	比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。
 * 	3）非终结符表达式：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，
 * 	比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。
 * 	非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。
 * 	4）环境角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，
 * 	比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。
 * 
 * 优缺点
 * 	解释器是一个简单的语法分析工具，它最显著的优点就是扩展性，修改语法规则只需要修改相应的非终结符就可以了，
 * 	若扩展语法，只需要增加非终结符类就可以了。比如我们现在需要修改Plus的含义，那么只需要修改Plus类即可，
 * 	如果要增加乘法操作，那么也只需要增加一个Multiple类就行。
 * 	但是，解释器模式会引起类的膨胀，每个语法都需要产生一个非终结符表达式，语法规则比较复杂时，
 * 	就可能产生大量的类文件，为维护带来非常多的麻烦。同时，从例子我们也可以看到，整个表达式的运算过程采用了递归调用方法，
 * 	每个非终结符表达式只关心与自己相关的表达式，每个表达式需要知道最终的结果，
 * 	必须通过递归方式，无论是面向对象的语言还是面向过程的语言，递归都是一个不推荐的方式。
 * 	由于使用了大量的循环和递归，效率是一个不容忽视的问题。特别是用于解释一个解析复杂、冗长的语法时，效率是难以忍受的。
 * 
 * 使用场景
 * 	一些重复发生的事情包含固定的一系列操作类型，比较适合用解释器模式来实现。
 * 	比如加减乘除四则运算，但是公式每次都不同，比如可配置，有时是a + b - c x d，有时是a x b + c - d，等等等等个，
 * 	公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。
 * 
 * 测试类
 * 
 * 例子：我们需要一个能够解释加法和减法的解释器，那么最好的方式就是用解释器模式来实现。
 * 
 * @author yangrun
 * @date 2018年11月30日
 */
public class Client {

	public static void main(String[] args) {
		Context ctx = new Context();
		Variable x = new Variable("x");
		Variable y = new Variable("y");
		Constant c = new Constant(1);
		ctx.assign(x, 2);
		ctx.assign(y, 3);

		AbstractExpression exp = new Plus(new Plus(c, x), new Minus(y, x));
		System.out.println(exp.toString() + " = " + exp.interpret(ctx));
	}

}